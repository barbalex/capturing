-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.

CREATE OR REPLACE FUNCTION public.file_revs_children(
	file_id uuid,
	parent_rev text)
    RETURNS SETOF file_revs 
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
  SELECT
    *
  FROM
    file_revs
  WHERE
    file_revs.file_id = $1
    -- its parent is the file_rev, thus this is its child
    AND file_revs.parent_rev = $2
$BODY$;

ALTER FUNCTION public.file_revs_children(uuid, text)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.file_revs_children(uuid, text) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.file_revs_children(uuid, text) TO anon;

GRANT EXECUTE ON FUNCTION public.file_revs_children(uuid, text) TO authenticated;

GRANT EXECUTE ON FUNCTION public.file_revs_children(uuid, text) TO postgres;

GRANT EXECUTE ON FUNCTION public.file_revs_children(uuid, text) TO service_role;

CREATE OR REPLACE FUNCTION public.row_conflicts_of_winner(
	row_id uuid,
	deleted boolean DEFAULT false)
    RETURNS text[]
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
  SELECT
    ARRAY (
      SELECT
        rev
      FROM
        row_revs_leaves ($1, $2)
      WHERE
        rev <> row_revs.rev)
  FROM
    row_revs_winner ($1, $2) AS row_revs
$BODY$;

ALTER FUNCTION public.row_conflicts_of_winner(uuid, boolean)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.row_conflicts_of_winner(uuid, boolean) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.row_conflicts_of_winner(uuid, boolean) TO anon;

GRANT EXECUTE ON FUNCTION public.row_conflicts_of_winner(uuid, boolean) TO authenticated;

GRANT EXECUTE ON FUNCTION public.row_conflicts_of_winner(uuid, boolean) TO postgres;

GRANT EXECUTE ON FUNCTION public.row_conflicts_of_winner(uuid, boolean) TO service_role;

CREATE OR REPLACE FUNCTION public.file_revs_winner_rev_value(
	file_id uuid,
	deleted boolean DEFAULT false)
    RETURNS text
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
  SELECT
    -- here we choose the winning revision
    max(leaves.rev) AS rev
  FROM
    file_revs_leaves ($1, $2) AS leaves
WHERE
  file_revs_max_depth ($1, $2) = leaves.depth
$BODY$;

ALTER FUNCTION public.file_revs_winner_rev_value(uuid, boolean)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.file_revs_winner_rev_value(uuid, boolean) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.file_revs_winner_rev_value(uuid, boolean) TO anon;

GRANT EXECUTE ON FUNCTION public.file_revs_winner_rev_value(uuid, boolean) TO authenticated;

GRANT EXECUTE ON FUNCTION public.file_revs_winner_rev_value(uuid, boolean) TO postgres;

GRANT EXECUTE ON FUNCTION public.file_revs_winner_rev_value(uuid, boolean) TO service_role;

CREATE OR REPLACE FUNCTION public.row_revs_children(
	row_id uuid,
	parent_rev text)
    RETURNS SETOF row_revs 
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
  SELECT
    *
  FROM
    row_revs
  WHERE
    row_revs.row_id = $1
    -- its parent is the row_rev, thus this is its child
    AND row_revs.parent_rev = $2
$BODY$;

ALTER FUNCTION public.row_revs_children(uuid, text)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.row_revs_children(uuid, text) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.row_revs_children(uuid, text) TO anon;

GRANT EXECUTE ON FUNCTION public.row_revs_children(uuid, text) TO authenticated;

GRANT EXECUTE ON FUNCTION public.row_revs_children(uuid, text) TO postgres;

GRANT EXECUTE ON FUNCTION public.row_revs_children(uuid, text) TO service_role;

CREATE OR REPLACE FUNCTION public.row_revs_max_depth(
	row_id uuid,
	deleted boolean DEFAULT false)
    RETURNS integer
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
  SELECT
    max(depth)
  FROM
    row_revs_leaves ($1, $2);

$BODY$;

ALTER FUNCTION public.row_revs_max_depth(uuid, boolean)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.row_revs_max_depth(uuid, boolean) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.row_revs_max_depth(uuid, boolean) TO anon;

GRANT EXECUTE ON FUNCTION public.row_revs_max_depth(uuid, boolean) TO authenticated;

GRANT EXECUTE ON FUNCTION public.row_revs_max_depth(uuid, boolean) TO postgres;

GRANT EXECUTE ON FUNCTION public.row_revs_max_depth(uuid, boolean) TO service_role;

CREATE OR REPLACE FUNCTION public.file_revs_max_depth(
	file_id uuid,
	deleted boolean DEFAULT false)
    RETURNS integer
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
  SELECT
    max(depth)
  FROM
    file_revs_leaves ($1, $2);

$BODY$;

ALTER FUNCTION public.file_revs_max_depth(uuid, boolean)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.file_revs_max_depth(uuid, boolean) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.file_revs_max_depth(uuid, boolean) TO anon;

GRANT EXECUTE ON FUNCTION public.file_revs_max_depth(uuid, boolean) TO authenticated;

GRANT EXECUTE ON FUNCTION public.file_revs_max_depth(uuid, boolean) TO postgres;

GRANT EXECUTE ON FUNCTION public.file_revs_max_depth(uuid, boolean) TO service_role;

CREATE OR REPLACE FUNCTION public.file_revs_winner(
	file_id uuid,
	deleted boolean DEFAULT false)
    RETURNS SETOF file_revs 
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
  SELECT
    *
  FROM
    file_revs_leaves ($1, $2) AS leaves
WHERE
  leaves.rev = file_revs_winner_rev_value ($1, $2)
  OR (leaves.rev IS NULL
    AND file_revs_winner_rev_value ($1, $2) IS NULL)
$BODY$;

ALTER FUNCTION public.file_revs_winner(uuid, boolean)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.file_revs_winner(uuid, boolean) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.file_revs_winner(uuid, boolean) TO anon;

GRANT EXECUTE ON FUNCTION public.file_revs_winner(uuid, boolean) TO authenticated;

GRANT EXECUTE ON FUNCTION public.file_revs_winner(uuid, boolean) TO postgres;

GRANT EXECUTE ON FUNCTION public.file_revs_winner(uuid, boolean) TO service_role;

CREATE OR REPLACE FUNCTION public.row_revs_winner_rev_value(
	row_id uuid,
	deleted boolean DEFAULT false)
    RETURNS text
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
  SELECT
    -- here we choose the winning revision
    max(leaves.rev) AS rev
  FROM
    row_revs_leaves ($1, $2) AS leaves
WHERE
  row_revs_max_depth ($1, $2) = leaves.depth
$BODY$;

ALTER FUNCTION public.row_revs_winner_rev_value(uuid, boolean)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.row_revs_winner_rev_value(uuid, boolean) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.row_revs_winner_rev_value(uuid, boolean) TO anon;

GRANT EXECUTE ON FUNCTION public.row_revs_winner_rev_value(uuid, boolean) TO authenticated;

GRANT EXECUTE ON FUNCTION public.row_revs_winner_rev_value(uuid, boolean) TO postgres;

GRANT EXECUTE ON FUNCTION public.row_revs_winner_rev_value(uuid, boolean) TO service_role;

CREATE OR REPLACE FUNCTION public.row_revs_winner(
	row_id uuid,
	deleted boolean DEFAULT false)
    RETURNS SETOF row_revs 
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
  SELECT
    *
  FROM
    row_revs_leaves ($1, $2) AS leaves
WHERE
  leaves.rev = row_revs_winner_rev_value ($1, $2)
  OR (leaves.rev IS NULL
    AND row_revs_winner_rev_value ($1, $2) IS NULL)
$BODY$;

ALTER FUNCTION public.row_revs_winner(uuid, boolean)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.row_revs_winner(uuid, boolean) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.row_revs_winner(uuid, boolean) TO anon;

GRANT EXECUTE ON FUNCTION public.row_revs_winner(uuid, boolean) TO authenticated;

GRANT EXECUTE ON FUNCTION public.row_revs_winner(uuid, boolean) TO postgres;

GRANT EXECUTE ON FUNCTION public.row_revs_winner(uuid, boolean) TO service_role;

CREATE OR REPLACE FUNCTION public.file_conflicts_of_winner(
	file_id uuid,
	deleted boolean DEFAULT false)
    RETURNS text[]
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
  SELECT
    ARRAY (
      SELECT
        rev
      FROM
        file_revs_leaves ($1, $2)
      WHERE
        rev <> file_revs.rev)
  FROM
    file_revs_winner ($1, $2) AS file_revs
$BODY$;

ALTER FUNCTION public.file_conflicts_of_winner(uuid, boolean)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.file_conflicts_of_winner(uuid, boolean) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.file_conflicts_of_winner(uuid, boolean) TO anon;

GRANT EXECUTE ON FUNCTION public.file_conflicts_of_winner(uuid, boolean) TO authenticated;

GRANT EXECUTE ON FUNCTION public.file_conflicts_of_winner(uuid, boolean) TO postgres;

GRANT EXECUTE ON FUNCTION public.file_conflicts_of_winner(uuid, boolean) TO service_role;

CREATE OR REPLACE FUNCTION public.row_revs_leaves(
	row_id uuid,
	deleted boolean DEFAULT false)
    RETURNS SETOF row_revs 
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
  SELECT
    *
  FROM
    row_revs
  WHERE
    -- of this record
    row_id = $1
    -- undeleted
    AND deleted = $2
    -- leaves
    AND NOT EXISTS (
      SELECT
        1
      FROM
        row_revs_children ($1, row_revs.rev));

$BODY$;

ALTER FUNCTION public.row_revs_leaves(uuid, boolean)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.row_revs_leaves(uuid, boolean) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.row_revs_leaves(uuid, boolean) TO anon;

GRANT EXECUTE ON FUNCTION public.row_revs_leaves(uuid, boolean) TO authenticated;

GRANT EXECUTE ON FUNCTION public.row_revs_leaves(uuid, boolean) TO postgres;

GRANT EXECUTE ON FUNCTION public.row_revs_leaves(uuid, boolean) TO service_role;

CREATE OR REPLACE FUNCTION public.file_revs_leaves(
	file_id uuid,
	deleted boolean DEFAULT false)
    RETURNS SETOF file_revs 
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
  SELECT
    *
  FROM
    file_revs
  WHERE
    -- of this record
    file_id = $1
    -- undeleted
    AND deleted = $2
    -- leaves
    AND NOT EXISTS (
      SELECT
        1
      FROM
        file_revs_children ($1, file_revs.rev));

$BODY$;

ALTER FUNCTION public.file_revs_leaves(uuid, boolean)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.file_revs_leaves(uuid, boolean) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.file_revs_leaves(uuid, boolean) TO anon;

GRANT EXECUTE ON FUNCTION public.file_revs_leaves(uuid, boolean) TO authenticated;

GRANT EXECUTE ON FUNCTION public.file_revs_leaves(uuid, boolean) TO postgres;

GRANT EXECUTE ON FUNCTION public.file_revs_leaves(uuid, boolean) TO service_role;

CREATE OR REPLACE FUNCTION public.set_server_rev_at()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
begin
  new.server_rev_at = now();
  return new;
end;
$BODY$;

ALTER FUNCTION public.set_server_rev_at()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.set_server_rev_at() TO authenticated;

GRANT EXECUTE ON FUNCTION public.set_server_rev_at() TO postgres;

GRANT EXECUTE ON FUNCTION public.set_server_rev_at() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.set_server_rev_at() TO anon;

GRANT EXECUTE ON FUNCTION public.set_server_rev_at() TO service_role;

CREATE OR REPLACE FUNCTION public.file_revs_set_winning_revision()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
  IF EXISTS (
    SELECT
      1
    FROM
      file_revs_winner (NEW.file_id, FALSE))
  -- 1. if a winning undeleted leaf exists, use this
  --    (else pick a winner from the deleted leaves)
  THEN
  INSERT INTO files (id, row_id, field_id, filename, url, version, deleted, client_rev_at, client_rev_by, server_rev_at, rev, revisions, parent_rev, depth, conflicts)
  SELECT
    winner.file_id,
    row_id,
    winner.field_id,
    winner.filename,
    winner.url,
    winner.version,
    winner.deleted,
    winner.client_rev_at,
    winner.client_rev_by,
    now() as server_rev_at,
    winner.rev,
    winner.revisions,
    winner.parent_rev,
    winner.depth,
    file_conflicts_of_winner (NEW.file_id) AS conflicts
FROM
  file_revs_winner (NEW.file_id) AS winner
ON CONFLICT (id)
  DO UPDATE SET
    -- do not update the idrow_id,
    field_id = excluded.field_id,
    filename = excluded.filename,
    url = excluded.url,
    version = excluded.version,
    deleted = excluded.deleted,
    client_rev_at = excluded.client_rev_at,
    client_rev_by = excluded.client_rev_by,
    server_rev_at = excluded.server_rev_at,
    rev = excluded.rev,
    revisions = excluded.revisions,
    parent_rev = excluded.parent_rev,
    depth = excluded.depth,
    conflicts = excluded.conflicts;
ELSE
  -- 2. so there is no undeleted winning leaf
  --    choose winner from deleted leaves
  --    is necessary to set the winner deleted
  --    so the client can pick this up
  INSERT INTO files (id, row_id, field_id, filename, url, version, deleted, client_rev_at, client_rev_by, server_rev_at, rev, revisions, parent_rev, depth, conflicts)
  SELECT
    winner.file_id,
    row_id,
    winner.field_id,
    winner.filename,
    winner.url,
    winner.version,
    winner.deleted,
    winner.client_rev_at,
    winner.client_rev_by,
    now() as server_rev_at,
    winner.rev,
    winner.revisions,
    winner.parent_rev,
    winner.depth,
    file_conflicts_of_winner (NEW.file_id, TRUE) AS conflicts
  FROM
    file_revs_winner (NEW.file_id, TRUE) AS winner
ON CONFLICT (id)
  DO UPDATE SET
    -- do not update the idrow_id,
    field_id = excluded.field_id,
    filename = excluded.filename,
    url = excluded.url,
    version = excluded.version,
    deleted = excluded.deleted,
    client_rev_at = excluded.client_rev_at,
    client_rev_by = excluded.client_rev_by,
    server_rev_at = excluded.server_rev_at,
    rev = excluded.rev,
    revisions = excluded.revisions,
    parent_rev = excluded.parent_rev,
    depth = excluded.depth,
    conflicts = excluded.conflicts;
END IF;
  RETURN new;
END;
$BODY$;

ALTER FUNCTION public.file_revs_set_winning_revision()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.file_revs_set_winning_revision() TO authenticated;

GRANT EXECUTE ON FUNCTION public.file_revs_set_winning_revision() TO postgres;

GRANT EXECUTE ON FUNCTION public.file_revs_set_winning_revision() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.file_revs_set_winning_revision() TO anon;

GRANT EXECUTE ON FUNCTION public.file_revs_set_winning_revision() TO service_role;

CREATE OR REPLACE FUNCTION public.row_revs_set_winning_revision()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
  IF EXISTS (
    SELECT
      1
    FROM
      row_revs_winner (NEW.row_id, FALSE))
  -- 1. if a winning undeleted leaf exists, use this
  --    (else pick a winner from the deleted leaves)
  THEN
  INSERT INTO ROWS (id, table_id, parent_id, geometry, geometry_n, geometry_e, geometry_s, geometry_w, data, deleted, client_rev_at, client_rev_by, server_rev_at, rev, revisions, parent_rev, depth, conflicts)
  SELECT
    winner.row_id,
    winner.table_id,
    winner.parent_id,
    winner.geometry,
    winner.geometry_n,
    winner.geometry_e,
    winner.geometry_s,
    winner.geometry_w,
    winner.data,
    winner.deleted,
    winner.client_rev_at,
    winner.client_rev_by,
    now() as server_rev_at,
    winner.rev,
    winner.revisions,
    winner.parent_rev,
    winner.depth,
    row_conflicts_of_winner (NEW.row_id) AS conflicts
FROM
  row_revs_winner (NEW.row_id) AS winner
ON CONFLICT (id)
  DO UPDATE SET
    -- do not update the id
    table_id = excluded.table_id,
    parent_id = excluded.parent_id,
    geometry = excluded.geometry,
    geometry_n = excluded.geometry_n,
    geometry_e = excluded.geometry_e,
    geometry_s = excluded.geometry_s,
    geometry_w = excluded.geometry_w,
    data = excluded.data,
    deleted = excluded.deleted,
    client_rev_at = excluded.client_rev_at,
    client_rev_by = excluded.client_rev_by,
    server_rev_at = excluded.server_rev_at,
    rev = excluded.rev,
    revisions = excluded.revisions,
    parent_rev = excluded.parent_rev,
    depth = excluded.depth,
    conflicts = excluded.conflicts;
ELSE
  -- 2. so there is no undeleted winning leaf
  --    choose winner from deleted leaves
  --    is necessary to set the winner deleted
  --    so the client can pick this up
  INSERT INTO ROWS (id, table_id, parent_id, geometry, geometry_n, geometry_e, geometry_s, geometry_w, data, deleted, client_rev_at, client_rev_by, server_rev_at, rev, revisions, parent_rev, depth, conflicts)
  SELECT
    winner.row_id,
    winner.table_id,
    winner.parent_id,
    winner.geometry,
    winner.geometry_n,
    winner.geometry_e,
    winner.geometry_s,
    winner.geometry_w,
    winner.data,
    winner.deleted,
    winner.client_rev_at,
    winner.client_rev_by,
    now() as server_rev_at,
    winner.rev,
    winner.revisions,
    winner.parent_rev,
    winner.depth,
    row_conflicts_of_winner (NEW.row_id, TRUE) AS conflicts
  FROM
    row_revs_winner (NEW.row_id, TRUE) AS winner
ON CONFLICT (id)
  DO UPDATE SET
    -- do not update the id
    table_id = excluded.table_id,
    parent_id = excluded.parent_id,
    geometry = excluded.geometry,
    geometry_n = excluded.geometry_n,
    geometry_e = excluded.geometry_e,
    geometry_s = excluded.geometry_s,
    geometry_w = excluded.geometry_w,
    data = excluded.data,
    deleted = excluded.deleted,
    client_rev_at = excluded.client_rev_at,
    client_rev_by = excluded.client_rev_by,
    server_rev_at = excluded.server_rev_at,
    rev = excluded.rev,
    revisions = excluded.revisions,
    parent_rev = excluded.parent_rev,
    depth = excluded.depth,
    conflicts = excluded.conflicts;
END IF;
  RETURN new;
END;
$BODY$;

ALTER FUNCTION public.row_revs_set_winning_revision()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.row_revs_set_winning_revision() TO authenticated;

GRANT EXECUTE ON FUNCTION public.row_revs_set_winning_revision() TO postgres;

GRANT EXECUTE ON FUNCTION public.row_revs_set_winning_revision() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.row_revs_set_winning_revision() TO anon;

GRANT EXECUTE ON FUNCTION public.row_revs_set_winning_revision() TO service_role;

CREATE TABLE IF NOT EXISTS public.rel_types
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    value text COLLATE pg_catalog."default",
    sort smallint,
    comment text COLLATE pg_catalog."default",
    server_rev_at timestamp with time zone DEFAULT now(),
    deleted boolean DEFAULT false,
    CONSTRAINT rel_types_pkey PRIMARY KEY (id),
    CONSTRAINT rel_types_value_key UNIQUE (value)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.rel_types
    OWNER to postgres;

ALTER TABLE IF EXISTS public.rel_types
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.rel_types TO anon;

GRANT ALL ON TABLE public.rel_types TO authenticated;

GRANT ALL ON TABLE public.rel_types TO postgres;

GRANT ALL ON TABLE public.rel_types TO service_role;

COMMENT ON TABLE public.rel_types
    IS 'Goal: list of rel_types';

COMMENT ON COLUMN public.rel_types.value
    IS 'the relation type';

COMMENT ON COLUMN public.rel_types.sort
    IS 'enables sorting at will';

COMMENT ON COLUMN public.rel_types.comment
    IS 'explains the version type';

COMMENT ON COLUMN public.rel_types.server_rev_at
    IS 'time of last edit on server';
CREATE INDEX IF NOT EXISTS rel_types_deleted_idx
    ON public.rel_types USING btree
    (deleted ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS rel_types_server_rev_at_idx
    ON public.rel_types USING btree
    (server_rev_at ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS rel_types_sort_idx
    ON public.rel_types USING btree
    (sort ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS rel_types_value_idx
    ON public.rel_types USING btree
    (value COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "Users can view rel types"
    ON public.rel_types
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE TRIGGER rel_types_set_server_rev_at
    BEFORE INSERT OR UPDATE 
    ON public.rel_types
    FOR EACH ROW
    EXECUTE FUNCTION public.set_server_rev_at();

CREATE TABLE IF NOT EXISTS public.widget_types
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    value text COLLATE pg_catalog."default",
    needs_list boolean DEFAULT false,
    sort smallint,
    comment text COLLATE pg_catalog."default",
    server_rev_at timestamp with time zone DEFAULT now(),
    deleted boolean DEFAULT false,
    CONSTRAINT widget_types_pkey PRIMARY KEY (id),
    CONSTRAINT widget_types_value_key UNIQUE (value)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.widget_types
    OWNER to postgres;

ALTER TABLE IF EXISTS public.widget_types
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.widget_types TO anon;

GRANT ALL ON TABLE public.widget_types TO authenticated;

GRANT ALL ON TABLE public.widget_types TO postgres;

GRANT ALL ON TABLE public.widget_types TO service_role;

COMMENT ON TABLE public.widget_types
    IS 'Goal: list of widget_types';

COMMENT ON COLUMN public.widget_types.value
    IS 'the relation type';

COMMENT ON COLUMN public.widget_types.needs_list
    IS 'whether the widget needs an options list';

COMMENT ON COLUMN public.widget_types.sort
    IS 'enables sorting at will';

COMMENT ON COLUMN public.widget_types.comment
    IS 'explains the version type';

COMMENT ON COLUMN public.widget_types.server_rev_at
    IS 'time of last edit on server';
CREATE INDEX IF NOT EXISTS widget_types_deleted_idx
    ON public.widget_types USING btree
    (deleted ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS widget_types_server_rev_at_idx
    ON public.widget_types USING btree
    (server_rev_at ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS widget_types_sort_idx
    ON public.widget_types USING btree
    (sort ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS widget_types_value_idx
    ON public.widget_types USING btree
    (value COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "Users can view widget types"
    ON public.widget_types
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE TRIGGER widget_types_set_server_rev_at
    BEFORE INSERT OR UPDATE 
    ON public.widget_types
    FOR EACH ROW
    EXECUTE FUNCTION public.set_server_rev_at();

CREATE TABLE IF NOT EXISTS public.projects
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    account_id uuid NOT NULL,
    name text COLLATE pg_catalog."default",
    label text COLLATE pg_catalog."default",
    crs integer DEFAULT 4326,
    client_rev_at timestamp with time zone DEFAULT now(),
    client_rev_by text COLLATE pg_catalog."default",
    server_rev_at timestamp with time zone DEFAULT now(),
    deleted boolean DEFAULT false,
    CONSTRAINT projects_pkey PRIMARY KEY (id),
    CONSTRAINT projects_account_id_fkey FOREIGN KEY (account_id)
        REFERENCES public.accounts (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.projects
    OWNER to postgres;

ALTER TABLE IF EXISTS public.projects
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.projects TO anon;

GRANT ALL ON TABLE public.projects TO authenticated;

GRANT ALL ON TABLE public.projects TO postgres;

GRANT ALL ON TABLE public.projects TO service_role;

COMMENT ON TABLE public.projects
    IS 'Goal: Define data structure per project. Tables, rows and files depend on it. Not versioned (not recorded and only added by manager)';

COMMENT ON COLUMN public.projects.id
    IS 'primary key';

COMMENT ON COLUMN public.projects.account_id
    IS 'associated account';

COMMENT ON COLUMN public.projects.name
    IS 'name for use in db and url (lowercase, no special characters)';

COMMENT ON COLUMN public.projects.label
    IS 'name for use when labeling';

COMMENT ON COLUMN public.projects.crs
    IS 'crs used in geometry fields';

COMMENT ON COLUMN public.projects.client_rev_at
    IS 'time of last edit on client';

COMMENT ON COLUMN public.projects.client_rev_by
    IS 'user editing last on client';

COMMENT ON COLUMN public.projects.server_rev_at
    IS 'time of last edit on server';
CREATE UNIQUE INDEX IF NOT EXISTS account_name_idx
    ON public.projects USING btree
    (account_id ASC NULLS LAST, name COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default
    WHERE deleted IS FALSE;
CREATE INDEX IF NOT EXISTS projects_account_id_idx
    ON public.projects USING btree
    (account_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS projects_deleted_idx
    ON public.projects USING btree
    (deleted ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS projects_id_idx
    ON public.projects USING btree
    (id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS projects_label_idx
    ON public.projects USING btree
    (label COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS projects_name_idx
    ON public.projects USING btree
    (name COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "Users can update projects assigned and of own accounts"
    ON public.projects
    AS PERMISSIVE
    FOR UPDATE
    TO public
    WITH CHECK ((auth.uid() IN ( SELECT users.auth_user_id
   FROM (users
     JOIN project_users ON ((users.email = project_users.user_email)))
  WHERE ((project_users.project_id = projects.id) AND (project_users.role = ANY (ARRAY['project_manager'::text, 'project_editor'::text])))
UNION
 SELECT users.auth_user_id
   FROM users
  WHERE (users.account_id = projects.account_id))));
CREATE POLICY "Users can view assigned projects and projects of own accounts"
    ON public.projects
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() IN ( SELECT users.auth_user_id
   FROM (users
     JOIN project_users ON ((users.email = project_users.user_email)))
  WHERE (project_users.project_id = projects.id)
UNION
 SELECT users.auth_user_id
   FROM users
  WHERE (users.account_id = projects.account_id))));
CREATE POLICY "account owners can delete own projects"
    ON public.projects
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() IN ( SELECT users.auth_user_id
   FROM users
  WHERE (users.account_id = projects.account_id))));
CREATE POLICY "account owners can insert projects for own account"
    ON public.projects
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() IN ( SELECT users.auth_user_id
   FROM users
  WHERE (users.account_id = projects.account_id))));

CREATE TRIGGER projects_set_server_rev_at
    BEFORE INSERT OR UPDATE 
    ON public.projects
    FOR EACH ROW
    EXECUTE FUNCTION public.set_server_rev_at();

CREATE TABLE IF NOT EXISTS public.role_types
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    value text COLLATE pg_catalog."default",
    sort smallint DEFAULT 1,
    comment text COLLATE pg_catalog."default",
    server_rev_at timestamp with time zone DEFAULT now(),
    deleted boolean DEFAULT false,
    CONSTRAINT role_types_pkey PRIMARY KEY (id),
    CONSTRAINT role_types_value_key UNIQUE (value)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.role_types
    OWNER to postgres;

ALTER TABLE IF EXISTS public.role_types
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.role_types TO anon;

GRANT ALL ON TABLE public.role_types TO authenticated;

GRANT ALL ON TABLE public.role_types TO postgres;

GRANT ALL ON TABLE public.role_types TO service_role;

COMMENT ON TABLE public.role_types
    IS 'Goal: list of roles';

COMMENT ON COLUMN public.role_types.value
    IS 'the role';

COMMENT ON COLUMN public.role_types.sort
    IS 'enables sorting at will';

COMMENT ON COLUMN public.role_types.comment
    IS 'explains the role';

COMMENT ON COLUMN public.role_types.server_rev_at
    IS 'time of last edit on server';
CREATE INDEX IF NOT EXISTS role_types_deleted_idx
    ON public.role_types USING btree
    (deleted ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS role_types_server_rev_at_idx
    ON public.role_types USING btree
    (server_rev_at ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS role_types_sort_idx
    ON public.role_types USING btree
    (sort ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS role_types_value_idx
    ON public.role_types USING btree
    (value COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "Users can view role types"
    ON public.role_types
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE TRIGGER role_types_set_server_rev_at
    BEFORE INSERT OR UPDATE 
    ON public.role_types
    FOR EACH ROW
    EXECUTE FUNCTION public.set_server_rev_at();

CREATE TABLE IF NOT EXISTS public.files
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    row_id uuid NOT NULL,
    field_id uuid,
    filename text COLLATE pg_catalog."default",
    url text COLLATE pg_catalog."default",
    version integer DEFAULT 1,
    deleted boolean DEFAULT false,
    client_rev_at timestamp with time zone DEFAULT now(),
    client_rev_by text COLLATE pg_catalog."default",
    server_rev_at timestamp with time zone DEFAULT now(),
    rev text COLLATE pg_catalog."default",
    parent_rev text COLLATE pg_catalog."default",
    revisions text[] COLLATE pg_catalog."default",
    depth integer DEFAULT 0,
    conflicts text[] COLLATE pg_catalog."default",
    CONSTRAINT files_pkey PRIMARY KEY (id),
    CONSTRAINT files_field_id_fkey FOREIGN KEY (field_id)
        REFERENCES public.fields (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION,
    CONSTRAINT files_row_id_fkey FOREIGN KEY (row_id)
        REFERENCES public.rows (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.files
    OWNER to postgres;

ALTER TABLE IF EXISTS public.files
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.files TO authenticated;

GRANT ALL ON TABLE public.files TO anon;

GRANT ALL ON TABLE public.files TO service_role;

GRANT ALL ON TABLE public.files TO postgres;

COMMENT ON TABLE public.files
    IS 'Goal: Collect data. Versioned in db. Files managed following db data';

COMMENT ON COLUMN public.files.id
    IS 'primary key. used as filename in internal and cloud storage';

COMMENT ON COLUMN public.files.row_id
    IS 'associated row';

COMMENT ON COLUMN public.files.field_id
    IS 'associated field';

COMMENT ON COLUMN public.files.filename
    IS 'filename is set to this when exporting files';

COMMENT ON COLUMN public.files.url
    IS 'url to download the file at';

COMMENT ON COLUMN public.files.version
    IS 'is incremented on every edit of a pre-existing file. Enables clients to re-sync';

COMMENT ON COLUMN public.files.deleted
    IS 'marks if the file is deleted';

COMMENT ON COLUMN public.files.client_rev_at
    IS 'time of last edit on client';

COMMENT ON COLUMN public.files.client_rev_by
    IS 'user editing last on client';

COMMENT ON COLUMN public.files.server_rev_at
    IS 'time of last edit on server';
CREATE INDEX IF NOT EXISTS files_field_id_idx
    ON public.files USING btree
    (field_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS files_filename_idx
    ON public.files USING btree
    (filename COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS files_id_idx
    ON public.files USING btree
    (id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE UNIQUE INDEX IF NOT EXISTS files_row_field_filename_idx
    ON public.files USING btree
    (row_id ASC NULLS LAST, field_id ASC NULLS LAST, filename COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default
    WHERE deleted IS FALSE;
CREATE INDEX IF NOT EXISTS files_row_id_idx
    ON public.files USING btree
    (row_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "project managers and editors can delete files"
    ON public.files
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() IN ( SELECT users.auth_user_id
   FROM ((((rows
     JOIN tables ON ((rows.table_id = tables.id)))
     JOIN projects ON ((projects.id = tables.project_id)))
     JOIN project_users ON ((projects.id = project_users.project_id)))
     JOIN users ON ((users.email = project_users.user_email)))
  WHERE ((rows.id = files.row_id) AND (project_users.role = ANY (ARRAY['project_manager'::text, 'project_editor'::text]))))));
CREATE POLICY "project managers and editors can insert files"
    ON public.files
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() IN ( SELECT users.auth_user_id
   FROM ((((rows
     JOIN tables ON ((rows.table_id = tables.id)))
     JOIN projects ON ((projects.id = tables.project_id)))
     JOIN project_users ON ((projects.id = project_users.project_id)))
     JOIN users ON ((users.email = project_users.user_email)))
  WHERE ((rows.id = files.row_id) AND (project_users.role = ANY (ARRAY['project_manager'::text, 'project_editor'::text]))))));
CREATE POLICY "project managers and editors can update files"
    ON public.files
    AS PERMISSIVE
    FOR UPDATE
    TO public
    WITH CHECK ((auth.uid() IN ( SELECT users.auth_user_id
   FROM ((((rows
     JOIN tables ON ((rows.table_id = tables.id)))
     JOIN projects ON ((projects.id = tables.project_id)))
     JOIN project_users ON ((projects.id = project_users.project_id)))
     JOIN users ON ((users.email = project_users.user_email)))
  WHERE ((rows.id = files.row_id) AND (project_users.role = ANY (ARRAY['project_manager'::text, 'project_editor'::text]))))));
CREATE POLICY "project readers, editors and managers can view files"
    ON public.files
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() IN ( SELECT users.auth_user_id
   FROM ((((rows
     JOIN tables ON ((rows.table_id = tables.id)))
     JOIN projects ON ((projects.id = tables.project_id)))
     JOIN project_users ON ((projects.id = project_users.project_id)))
     JOIN users ON ((users.email = project_users.user_email)))
  WHERE ((rows.id = files.row_id) AND (project_users.role = ANY (ARRAY['project_manager'::text, 'project_editor'::text, 'project_reader'::text]))))));

CREATE TABLE IF NOT EXISTS public.row_revs
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    row_id uuid,
    table_id uuid,
    parent_id uuid,
    geometry geometry(GeometryCollection,4326) DEFAULT NULL::geometry,
    geometry_n real,
    geometry_e real,
    geometry_s real,
    geometry_w real,
    data jsonb,
    deleted boolean DEFAULT false,
    client_rev_at timestamp with time zone,
    client_rev_by text COLLATE pg_catalog."default",
    server_rev_at timestamp with time zone DEFAULT now(),
    rev text COLLATE pg_catalog."default",
    parent_rev text COLLATE pg_catalog."default",
    revisions text[] COLLATE pg_catalog."default",
    depth integer DEFAULT 0,
    CONSTRAINT row_revs_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.row_revs
    OWNER to postgres;

ALTER TABLE IF EXISTS public.row_revs
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.row_revs TO anon;

GRANT ALL ON TABLE public.row_revs TO authenticated;

GRANT ALL ON TABLE public.row_revs TO postgres;

GRANT ALL ON TABLE public.row_revs TO service_role;

COMMENT ON TABLE public.row_revs
    IS 'Goal: Sync rows and handle conflicts';

COMMENT ON COLUMN public.row_revs.id
    IS 'primary key';

COMMENT ON COLUMN public.row_revs.row_id
    IS 'key of table rows';

COMMENT ON COLUMN public.row_revs.parent_id
    IS 'associated row in the parent table (which means: this row is part of a child table)';

COMMENT ON COLUMN public.row_revs.rev
    IS 'hashed value the fields: row_id, table_id, geometry, data, deleted';

COMMENT ON COLUMN public.row_revs.parent_rev
    IS 'hash of the previous revision';

COMMENT ON COLUMN public.row_revs.revisions
    IS 'array of hashes of all previous revisions';

COMMENT ON COLUMN public.row_revs.depth
    IS 'depth of the revision tree';
CREATE INDEX IF NOT EXISTS row_revs_deleted_idx
    ON public.row_revs USING btree
    (deleted ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS row_revs_depth_idx
    ON public.row_revs USING btree
    (depth ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS row_revs_id_idx
    ON public.row_revs USING btree
    (id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS row_revs_parent_id_idx
    ON public.row_revs USING btree
    (parent_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS row_revs_parent_rev_idx
    ON public.row_revs USING btree
    (parent_rev COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS row_revs_rev_idx
    ON public.row_revs USING btree
    (rev COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS row_revs_row_id_idx
    ON public.row_revs USING btree
    (row_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS row_revs_server_rev_at_idx
    ON public.row_revs USING btree
    (server_rev_at ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "authenticated users can insert row_revs"
    ON public.row_revs
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.role() = 'authenticated'::text));
CREATE POLICY "authenticated users can view row_revs"
    ON public.row_revs
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.role() = 'authenticated'::text));
CREATE POLICY "row_revs can not be deleted"
    ON public.row_revs
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING (false);
CREATE POLICY "row_revs can not be updated"
    ON public.row_revs
    AS PERMISSIVE
    FOR UPDATE
    TO public
    WITH CHECK (false);

CREATE TRIGGER trigger_row_revs_set_winning_revision
    AFTER INSERT
    ON public.row_revs
    FOR EACH ROW
    EXECUTE FUNCTION public.row_revs_set_winning_revision();

CREATE TABLE IF NOT EXISTS public.fields
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    table_id uuid NOT NULL,
    name text COLLATE pg_catalog."default",
    label text COLLATE pg_catalog."default",
    sort smallint DEFAULT 0,
    is_internal_id boolean DEFAULT false,
    field_type text COLLATE pg_catalog."default" DEFAULT 'text'::text,
    widget_type text COLLATE pg_catalog."default" DEFAULT 'text'::text,
    options_table uuid,
    standard_value text COLLATE pg_catalog."default",
    client_rev_at timestamp with time zone DEFAULT now(),
    client_rev_by text COLLATE pg_catalog."default",
    server_rev_at timestamp with time zone DEFAULT now(),
    deleted boolean DEFAULT false,
    CONSTRAINT fields_pkey PRIMARY KEY (id),
    CONSTRAINT fields_field_type_fkey FOREIGN KEY (field_type)
        REFERENCES public.field_types (value) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION,
    CONSTRAINT fields_options_table_fkey FOREIGN KEY (options_table)
        REFERENCES public.tables (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION,
    CONSTRAINT fields_table_id_fkey FOREIGN KEY (table_id)
        REFERENCES public.tables (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION,
    CONSTRAINT fields_widget_type_fkey FOREIGN KEY (widget_type)
        REFERENCES public.widget_types (value) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.fields
    OWNER to postgres;

ALTER TABLE IF EXISTS public.fields
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.fields TO authenticated;

GRANT ALL ON TABLE public.fields TO anon;

GRANT ALL ON TABLE public.fields TO service_role;

GRANT ALL ON TABLE public.fields TO postgres;

COMMENT ON TABLE public.fields
    IS 'Goal: Define fields used per table. Defines structure and presentation of data column in rows. Not versioned (not recorded and only added by manager)';

COMMENT ON COLUMN public.fields.id
    IS 'primary key';

COMMENT ON COLUMN public.fields.table_id
    IS 'associated table';

COMMENT ON COLUMN public.fields.name
    IS 'name for use in db and url (lowercase, no special characters)';

COMMENT ON COLUMN public.fields.label
    IS 'name for use when labeling';

COMMENT ON COLUMN public.fields.sort
    IS 'enables ordering the field list of a table';

COMMENT ON COLUMN public.fields.is_internal_id
    IS 'is this table used as an id in the users own system?';

COMMENT ON COLUMN public.fields.field_type
    IS 'what type of data will populate this field?';

COMMENT ON COLUMN public.fields.widget_type
    IS 'what type of widget shall be used to enter data?';

COMMENT ON COLUMN public.fields.options_table
    IS 'for fields with field_type options-few and options-many: what table contains the options?';

COMMENT ON COLUMN public.fields.standard_value
    IS 'Goal: Project-admin can pre-set standard values. These are either real values (that have to be converted from string when used and field_type is not a string). Or instructions like: last(), now()...';

COMMENT ON COLUMN public.fields.client_rev_at
    IS 'time of last edit on client';

COMMENT ON COLUMN public.fields.client_rev_by
    IS 'user editing last on client';

COMMENT ON COLUMN public.fields.server_rev_at
    IS 'time of last edit on server';
CREATE INDEX IF NOT EXISTS fields_deleted_idx
    ON public.fields USING btree
    (deleted ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS fields_id_idx
    ON public.fields USING btree
    (id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS fields_label_idx
    ON public.fields USING btree
    (label COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS fields_name_idx
    ON public.fields USING btree
    (name COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS fields_options_table_idx
    ON public.fields USING btree
    (options_table ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS fields_sort_idx
    ON public.fields USING btree
    (sort ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS fields_table_id_idx
    ON public.fields USING btree
    (table_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE UNIQUE INDEX IF NOT EXISTS fields_table_name_idx
    ON public.fields USING btree
    (table_id ASC NULLS LAST, name COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default
    WHERE deleted IS FALSE;
CREATE POLICY "project managers can delete fields"
    ON public.fields
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() IN ( SELECT users.auth_user_id
   FROM (((tables
     JOIN projects ON ((projects.id = tables.project_id)))
     JOIN project_users ON ((projects.id = project_users.project_id)))
     JOIN users ON ((users.email = project_users.user_email)))
  WHERE ((tables.id = fields.table_id) AND (project_users.role = 'project_manager'::text)))));
CREATE POLICY "project managers can insert fields"
    ON public.fields
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() IN ( SELECT users.auth_user_id
   FROM (((tables
     JOIN projects ON ((projects.id = tables.project_id)))
     JOIN project_users ON ((projects.id = project_users.project_id)))
     JOIN users ON ((users.email = project_users.user_email)))
  WHERE ((tables.id = fields.table_id) AND (project_users.role = 'project_manager'::text)))));
CREATE POLICY "project managers can update fields"
    ON public.fields
    AS PERMISSIVE
    FOR UPDATE
    TO public
    WITH CHECK ((auth.uid() IN ( SELECT users.auth_user_id
   FROM (((tables
     JOIN projects ON ((projects.id = tables.project_id)))
     JOIN project_users ON ((projects.id = project_users.project_id)))
     JOIN users ON ((users.email = project_users.user_email)))
  WHERE ((tables.id = fields.table_id) AND (project_users.role = 'project_manager'::text)))));
CREATE POLICY "project readers, editors and managers can view fields"
    ON public.fields
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() IN ( SELECT users.auth_user_id
   FROM (((tables
     JOIN projects ON ((projects.id = tables.project_id)))
     JOIN project_users ON ((projects.id = project_users.project_id)))
     JOIN users ON ((users.email = project_users.user_email)))
  WHERE ((tables.id = fields.table_id) AND (project_users.role = ANY (ARRAY['project_manager'::text, 'project_editor'::text, 'project_reader'::text]))))));

CREATE TRIGGER fields_set_server_rev_at
    BEFORE INSERT OR UPDATE 
    ON public.fields
    FOR EACH ROW
    EXECUTE FUNCTION public.set_server_rev_at();

CREATE TABLE IF NOT EXISTS public.news
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    "time" timestamp with time zone DEFAULT now(),
    version_type text COLLATE pg_catalog."default" DEFAULT 'minor'::text,
    version text COLLATE pg_catalog."default",
    message text COLLATE pg_catalog."default",
    server_rev_at timestamp with time zone DEFAULT now(),
    deleted boolean DEFAULT false,
    CONSTRAINT news_pkey PRIMARY KEY (id),
    CONSTRAINT news_version_type_fkey FOREIGN KEY (version_type)
        REFERENCES public.version_types (value) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.news
    OWNER to postgres;

ALTER TABLE IF EXISTS public.news
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.news TO anon;

GRANT ALL ON TABLE public.news TO authenticated;

GRANT ALL ON TABLE public.news TO postgres;

GRANT ALL ON TABLE public.news TO service_role;

COMMENT ON COLUMN public.news.id
    IS 'primary key';

COMMENT ON COLUMN public.news."time"
    IS 'time the news was created';

COMMENT ON COLUMN public.news.version_type
    IS 'associated version_type';

COMMENT ON COLUMN public.news.version
    IS 'version the news refers to';

COMMENT ON COLUMN public.news.message
    IS 'this is the news';

COMMENT ON COLUMN public.news.server_rev_at
    IS 'time of last edit on server';
CREATE INDEX IF NOT EXISTS news_deleted_idx
    ON public.news USING btree
    (deleted ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS news_id_idx
    ON public.news USING btree
    (id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS news_time_idx
    ON public.news USING btree
    ("time" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS news_version_type_idx
    ON public.news USING btree
    (version_type COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "Users can view news"
    ON public.news
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE TRIGGER news_set_server_rev_at
    BEFORE INSERT OR UPDATE 
    ON public.news
    FOR EACH ROW
    EXECUTE FUNCTION public.set_server_rev_at();

CREATE TABLE IF NOT EXISTS public.tile_layers
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    label text COLLATE pg_catalog."default",
    url_template text COLLATE pg_catalog."default",
    subdomains text[] COLLATE pg_catalog."default",
    max_zoom numeric DEFAULT 19,
    min_zoom numeric DEFAULT 0,
    opacity numeric DEFAULT 1,
    wms_base_url text COLLATE pg_catalog."default",
    wms_format text COLLATE pg_catalog."default",
    wms_layers text[] COLLATE pg_catalog."default",
    wms_parameters jsonb,
    wms_request text COLLATE pg_catalog."default" DEFAULT 'GetMap'::text,
    wms_service text COLLATE pg_catalog."default" DEFAULT 'WMS'::text,
    wms_styles text[] COLLATE pg_catalog."default",
    wms_transparent boolean DEFAULT false,
    wms_version text COLLATE pg_catalog."default",
    client_rev_at timestamp with time zone DEFAULT now(),
    client_rev_by text COLLATE pg_catalog."default",
    server_rev_at timestamp with time zone DEFAULT now(),
    deleted boolean DEFAULT false,
    CONSTRAINT tile_layers_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.tile_layers
    OWNER to postgres;

ALTER TABLE IF EXISTS public.tile_layers
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.tile_layers TO anon;

GRANT ALL ON TABLE public.tile_layers TO authenticated;

GRANT ALL ON TABLE public.tile_layers TO postgres;

GRANT ALL ON TABLE public.tile_layers TO service_role;
CREATE INDEX IF NOT EXISTS tile_layers_deleted_idx
    ON public.tile_layers USING btree
    (deleted ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS tile_layers_id_idx
    ON public.tile_layers USING btree
    (id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "authenticated users can view tile_layers"
    ON public.tile_layers
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.role() = 'authenticated'::text));
CREATE POLICY "project_managers can delete tile_layers"
    ON public.tile_layers
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() IN ( SELECT users.auth_user_id
   FROM (users
     JOIN project_users ON ((users.email = project_users.user_email)))
  WHERE (project_users.role = 'project_manager'::text))));
CREATE POLICY "project_managers can insert tile_layers"
    ON public.tile_layers
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() IN ( SELECT users.auth_user_id
   FROM (users
     JOIN project_users ON ((users.email = project_users.user_email)))
  WHERE (project_users.role = 'project_manager'::text))));
CREATE POLICY "project_managers can update tile_layers"
    ON public.tile_layers
    AS PERMISSIVE
    FOR UPDATE
    TO public
    WITH CHECK ((auth.uid() IN ( SELECT users.auth_user_id
   FROM (users
     JOIN project_users ON ((users.email = project_users.user_email)))
  WHERE (project_users.role = 'project_manager'::text))));

CREATE TRIGGER tile_layers_set_server_rev_at
    BEFORE INSERT OR UPDATE 
    ON public.tile_layers
    FOR EACH ROW
    EXECUTE FUNCTION public.set_server_rev_at();

CREATE TABLE IF NOT EXISTS public.widgets_for_fields
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    field_value text COLLATE pg_catalog."default",
    widget_value text COLLATE pg_catalog."default",
    server_rev_at timestamp with time zone DEFAULT now(),
    deleted boolean DEFAULT false,
    CONSTRAINT widgets_for_fields_pkey PRIMARY KEY (id),
    CONSTRAINT widgets_for_fields_field_value_widget_value_key UNIQUE (field_value, widget_value),
    CONSTRAINT widgets_for_fields_field_value_fkey FOREIGN KEY (field_value)
        REFERENCES public.field_types (value) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    CONSTRAINT widgets_for_fields_widget_value_fkey FOREIGN KEY (widget_value)
        REFERENCES public.widget_types (value) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.widgets_for_fields
    OWNER to postgres;

ALTER TABLE IF EXISTS public.widgets_for_fields
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.widgets_for_fields TO authenticated;

GRANT ALL ON TABLE public.widgets_for_fields TO anon;

GRANT ALL ON TABLE public.widgets_for_fields TO service_role;

GRANT ALL ON TABLE public.widgets_for_fields TO postgres;

COMMENT ON TABLE public.widgets_for_fields
    IS 'Goal: know what widgets can be choosen for what field_types';

COMMENT ON COLUMN public.widgets_for_fields.server_rev_at
    IS 'time of last edit on server';
CREATE INDEX IF NOT EXISTS widgets_for_fields_deleted_idx
    ON public.widgets_for_fields USING btree
    (deleted ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS widgets_for_fields_field_value_idx
    ON public.widgets_for_fields USING btree
    (field_value COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS widgets_for_fields_server_rev_at_idx
    ON public.widgets_for_fields USING btree
    (server_rev_at ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS widgets_for_fields_widget_value_idx
    ON public.widgets_for_fields USING btree
    (widget_value COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "Users can view widgets for fields"
    ON public.widgets_for_fields
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE TABLE IF NOT EXISTS public.project_users
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    project_id uuid NOT NULL,
    user_email text COLLATE pg_catalog."default" NOT NULL,
    role text COLLATE pg_catalog."default" DEFAULT 'project_reader'::text,
    client_rev_at timestamp with time zone DEFAULT now(),
    client_rev_by text COLLATE pg_catalog."default",
    server_rev_at timestamp with time zone DEFAULT now(),
    deleted boolean DEFAULT false,
    CONSTRAINT project_users_pkey PRIMARY KEY (id),
    CONSTRAINT project_users_project_id_fkey FOREIGN KEY (project_id)
        REFERENCES public.projects (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION,
    CONSTRAINT project_users_role_fkey FOREIGN KEY (role)
        REFERENCES public.role_types (value) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.project_users
    OWNER to postgres;

ALTER TABLE IF EXISTS public.project_users
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.project_users TO authenticated;

GRANT ALL ON TABLE public.project_users TO anon;

GRANT ALL ON TABLE public.project_users TO service_role;

GRANT ALL ON TABLE public.project_users TO postgres;

COMMENT ON TABLE public.project_users
    IS 'Goal: Bring your own tile layers. Not versioned (not recorded and only added by manager). Field definitions, see: https://pub.dev/documentation/flutter_map/latest/flutter_map/flutter_map-library.html';

COMMENT ON COLUMN public.project_users.id
    IS 'primary key';

COMMENT ON COLUMN public.project_users.project_id
    IS 'associated project';

COMMENT ON COLUMN public.project_users.user_email
    IS 'associated user';

COMMENT ON COLUMN public.project_users.role
    IS 'associated role';

COMMENT ON COLUMN public.project_users.client_rev_at
    IS 'time of last edit on client';

COMMENT ON COLUMN public.project_users.client_rev_by
    IS 'user editing last on client';

COMMENT ON COLUMN public.project_users.server_rev_at
    IS 'time of last edit on server';
CREATE INDEX IF NOT EXISTS project_users_deleted_idx
    ON public.project_users USING btree
    (deleted ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS project_users_id_idx
    ON public.project_users USING btree
    (id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE UNIQUE INDEX IF NOT EXISTS project_users_project_email_idx
    ON public.project_users USING btree
    (project_id ASC NULLS LAST, user_email COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default
    WHERE deleted IS FALSE;
CREATE INDEX IF NOT EXISTS project_users_project_id_idx
    ON public.project_users USING btree
    (project_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS project_users_role_idx
    ON public.project_users USING btree
    (role COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS project_users_user_email_idx
    ON public.project_users USING btree
    (user_email COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "project owners and same user can view project_users"
    ON public.project_users
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() IN ( SELECT users.auth_user_id
   FROM users
  WHERE (users.account_id = ( SELECT projects.account_id
           FROM projects
          WHERE (projects.id = project_users.project_id)))
UNION
 SELECT users.auth_user_id
   FROM users
  WHERE (users.email = project_users.user_email))));
CREATE POLICY "project owners can delete project_users"
    ON public.project_users
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() IN ( SELECT users.auth_user_id
   FROM users
  WHERE (users.account_id = ( SELECT projects.account_id
           FROM projects
          WHERE (projects.id = project_users.project_id))))));
CREATE POLICY "project owners can insert project_users"
    ON public.project_users
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() IN ( SELECT users.auth_user_id
   FROM users
  WHERE (users.account_id = ( SELECT projects.account_id
           FROM projects
          WHERE (projects.id = project_users.project_id))))));
CREATE POLICY "project owners can update project_users"
    ON public.project_users
    AS PERMISSIVE
    FOR UPDATE
    TO public
    WITH CHECK ((auth.uid() IN ( SELECT users.auth_user_id
   FROM users
  WHERE (users.account_id = ( SELECT projects.account_id
           FROM projects
          WHERE (projects.id = project_users.project_id))))));

CREATE TRIGGER project_users_set_server_rev_at
    BEFORE INSERT OR UPDATE 
    ON public.project_users
    FOR EACH ROW
    EXECUTE FUNCTION public.set_server_rev_at();

CREATE TABLE IF NOT EXISTS public.option_types
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    value text COLLATE pg_catalog."default",
    save_id boolean DEFAULT false,
    sort smallint,
    comment text COLLATE pg_catalog."default",
    server_rev_at timestamp with time zone DEFAULT now(),
    deleted boolean DEFAULT false,
    CONSTRAINT option_types_pkey PRIMARY KEY (id),
    CONSTRAINT option_types_value_key UNIQUE (value)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.option_types
    OWNER to postgres;

ALTER TABLE IF EXISTS public.option_types
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.option_types TO anon;

GRANT ALL ON TABLE public.option_types TO authenticated;

GRANT ALL ON TABLE public.option_types TO postgres;

GRANT ALL ON TABLE public.option_types TO service_role;

COMMENT ON TABLE public.option_types
    IS 'Goal: list of types of option tables';

COMMENT ON COLUMN public.option_types.id
    IS 'the id to use if id instead of value is to be saved';

COMMENT ON COLUMN public.option_types.value
    IS 'explains the option type';

COMMENT ON COLUMN public.option_types.save_id
    IS 'wether to save id instead of value';

COMMENT ON COLUMN public.option_types.sort
    IS 'enables sorting at will';

COMMENT ON COLUMN public.option_types.server_rev_at
    IS 'time of last edit on server';
CREATE INDEX IF NOT EXISTS option_types_deleted_idx
    ON public.option_types USING btree
    (deleted ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS option_types_id_idx
    ON public.option_types USING btree
    (id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS option_types_server_rev_at_idx
    ON public.option_types USING btree
    (server_rev_at ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS option_types_sort_idx
    ON public.option_types USING btree
    (sort ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS option_types_value_idx
    ON public.option_types USING btree
    (value COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "Users can view option types"
    ON public.option_types
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE TABLE IF NOT EXISTS public.project_tile_layers
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    label text COLLATE pg_catalog."default",
    sort smallint DEFAULT 0,
    active boolean DEFAULT false,
    project_id uuid NOT NULL,
    url_template text COLLATE pg_catalog."default",
    subdomains text[] COLLATE pg_catalog."default",
    max_zoom numeric DEFAULT 19,
    min_zoom numeric DEFAULT 0,
    opacity numeric DEFAULT 1,
    wms_base_url text COLLATE pg_catalog."default",
    wms_format text COLLATE pg_catalog."default",
    wms_layers text[] COLLATE pg_catalog."default",
    wms_parameters jsonb,
    wms_request text COLLATE pg_catalog."default" DEFAULT 'GetMap'::text,
    wms_service text COLLATE pg_catalog."default" DEFAULT 'WMS'::text,
    wms_styles text[] COLLATE pg_catalog."default",
    wms_transparent boolean DEFAULT false,
    wms_version text COLLATE pg_catalog."default",
    client_rev_at timestamp with time zone DEFAULT now(),
    client_rev_by text COLLATE pg_catalog."default",
    server_rev_at timestamp with time zone DEFAULT now(),
    deleted boolean DEFAULT false,
    CONSTRAINT project_tile_layers_pkey PRIMARY KEY (id),
    CONSTRAINT project_tile_layers_project_id_fkey FOREIGN KEY (project_id)
        REFERENCES public.projects (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE RESTRICT
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.project_tile_layers
    OWNER to postgres;

ALTER TABLE IF EXISTS public.project_tile_layers
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.project_tile_layers TO anon;

GRANT ALL ON TABLE public.project_tile_layers TO authenticated;

GRANT ALL ON TABLE public.project_tile_layers TO postgres;

GRANT ALL ON TABLE public.project_tile_layers TO service_role;
CREATE INDEX IF NOT EXISTS project_tile_layers_deleted_idx
    ON public.project_tile_layers USING btree
    (deleted ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS project_tile_layers_id_idx
    ON public.project_tile_layers USING btree
    (id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS project_tile_layers_sort_idx
    ON public.project_tile_layers USING btree
    (sort ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "project managers can delete project_tile_layers"
    ON public.project_tile_layers
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() IN ( SELECT users.auth_user_id
   FROM ((projects
     JOIN project_users ON ((projects.id = project_users.project_id)))
     JOIN users ON ((users.email = project_users.user_email)))
  WHERE ((projects.id = project_tile_layers.project_id) AND (project_users.role = 'project_manager'::text)))));
CREATE POLICY "project managers can insert project_tile_layers"
    ON public.project_tile_layers
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() IN ( SELECT users.auth_user_id
   FROM ((projects
     JOIN project_users ON ((projects.id = project_users.project_id)))
     JOIN users ON ((users.email = project_users.user_email)))
  WHERE ((projects.id = project_tile_layers.project_id) AND (project_users.role = 'project_manager'::text)))));
CREATE POLICY "project managers can update project_tile_layers"
    ON public.project_tile_layers
    AS PERMISSIVE
    FOR UPDATE
    TO public
    WITH CHECK ((auth.uid() IN ( SELECT users.auth_user_id
   FROM ((projects
     JOIN project_users ON ((projects.id = project_users.project_id)))
     JOIN users ON ((users.email = project_users.user_email)))
  WHERE ((projects.id = project_tile_layers.project_id) AND (project_users.role = 'project_manager'::text)))));
CREATE POLICY "project readers, editors and managers can view project_tile_lay"
    ON public.project_tile_layers
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() IN ( SELECT users.auth_user_id
   FROM ((projects
     JOIN project_users ON ((projects.id = project_users.project_id)))
     JOIN users ON ((users.email = project_users.user_email)))
  WHERE ((projects.id = project_tile_layers.project_id) AND (project_users.role = ANY (ARRAY['project_manager'::text, 'project_editor'::text, 'project_reader'::text]))))));

CREATE TRIGGER project_tile_layers_set_server_rev_at
    BEFORE INSERT OR UPDATE 
    ON public.project_tile_layers
    FOR EACH ROW
    EXECUTE FUNCTION public.set_server_rev_at();

CREATE TABLE IF NOT EXISTS public.users
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    name text COLLATE pg_catalog."default",
    email text COLLATE pg_catalog."default",
    account_id uuid,
    auth_user_id uuid,
    client_rev_at timestamp with time zone DEFAULT now(),
    client_rev_by text COLLATE pg_catalog."default",
    server_rev_at timestamp with time zone DEFAULT now(),
    deleted boolean DEFAULT false,
    CONSTRAINT users_pkey PRIMARY KEY (id),
    CONSTRAINT users_email_key UNIQUE (email),
    CONSTRAINT users_account_id_fkey FOREIGN KEY (account_id)
        REFERENCES public.accounts (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.users
    OWNER to postgres;

ALTER TABLE IF EXISTS public.users
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.users TO authenticated;

GRANT ALL ON TABLE public.users TO anon;

GRANT ALL ON TABLE public.users TO service_role;

GRANT ALL ON TABLE public.users TO postgres;

COMMENT ON TABLE public.users
    IS 'Goal: authentication, authorization, communication, configuration. Not versioned (not recorded and only added by manager)';

COMMENT ON COLUMN public.users.id
    IS 'primary key';

COMMENT ON COLUMN public.users.name
    IS 'name';

COMMENT ON COLUMN public.users.email
    IS 'email';

COMMENT ON COLUMN public.users.account_id
    IS 'associated account';

COMMENT ON COLUMN public.users.auth_user_id
    IS 'associated auth';

COMMENT ON COLUMN public.users.client_rev_at
    IS 'time of last edit on client';

COMMENT ON COLUMN public.users.client_rev_by
    IS 'user editing last on client';

COMMENT ON COLUMN public.users.server_rev_at
    IS 'time of last edit on server';
CREATE INDEX IF NOT EXISTS users_account_id_idx
    ON public.users USING btree
    (account_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS users_auth_user_id_idx
    ON public.users USING btree
    (auth_user_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS users_deleted_idx
    ON public.users USING btree
    (deleted ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS users_email_idx
    ON public.users USING btree
    (email COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS users_id_idx
    ON public.users USING btree
    (id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS users_name_idx
    ON public.users USING btree
    (name COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "Users can insert own user"
    ON public.users
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() = auth_user_id));
CREATE POLICY "Users can update own user"
    ON public.users
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = auth_user_id));
CREATE POLICY "Users can view own user"
    ON public.users
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() = auth_user_id));

CREATE TRIGGER users_set_server_rev_at
    BEFORE INSERT OR UPDATE 
    ON public.users
    FOR EACH ROW
    EXECUTE FUNCTION public.set_server_rev_at();

CREATE TABLE IF NOT EXISTS public.field_types
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    value text COLLATE pg_catalog."default",
    sort smallint,
    comment text COLLATE pg_catalog."default",
    server_rev_at timestamp with time zone DEFAULT now(),
    deleted boolean DEFAULT false,
    CONSTRAINT field_types_pkey PRIMARY KEY (id),
    CONSTRAINT field_types_value_key UNIQUE (value)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.field_types
    OWNER to postgres;

ALTER TABLE IF EXISTS public.field_types
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.field_types TO anon;

GRANT ALL ON TABLE public.field_types TO authenticated;

GRANT ALL ON TABLE public.field_types TO postgres;

GRANT ALL ON TABLE public.field_types TO service_role;

COMMENT ON TABLE public.field_types
    IS 'Goal: list of field_types';

COMMENT ON COLUMN public.field_types.value
    IS 'explains the version type';

COMMENT ON COLUMN public.field_types.sort
    IS 'enables sorting at will';

COMMENT ON COLUMN public.field_types.server_rev_at
    IS 'time of last edit on server';
CREATE INDEX IF NOT EXISTS field_types_deleted_idx
    ON public.field_types USING btree
    (deleted ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS field_types_server_rev_at_idx
    ON public.field_types USING btree
    (server_rev_at ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS field_types_sort_idx
    ON public.field_types USING btree
    (sort ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS field_types_value_idx
    ON public.field_types USING btree
    (value COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "Users can view field types"
    ON public.field_types
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE TRIGGER field_types_set_server_rev_at
    BEFORE INSERT OR UPDATE 
    ON public.field_types
    FOR EACH ROW
    EXECUTE FUNCTION public.set_server_rev_at();

CREATE TABLE IF NOT EXISTS public.version_types
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    value text COLLATE pg_catalog."default",
    sort smallint,
    comment text COLLATE pg_catalog."default",
    server_rev_at timestamp with time zone DEFAULT now(),
    deleted boolean DEFAULT false,
    CONSTRAINT version_types_pkey PRIMARY KEY (id),
    CONSTRAINT version_types_value_key UNIQUE (value)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.version_types
    OWNER to postgres;

ALTER TABLE IF EXISTS public.version_types
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.version_types TO anon;

GRANT ALL ON TABLE public.version_types TO authenticated;

GRANT ALL ON TABLE public.version_types TO postgres;

GRANT ALL ON TABLE public.version_types TO service_role;

COMMENT ON TABLE public.version_types
    IS 'Goal: list of version_types';

COMMENT ON COLUMN public.version_types.value
    IS 'explains the version type';

COMMENT ON COLUMN public.version_types.sort
    IS 'enables sorting at will';

COMMENT ON COLUMN public.version_types.server_rev_at
    IS 'time of last edit on server';
CREATE INDEX IF NOT EXISTS version_types_deleted_idx
    ON public.version_types USING btree
    (deleted ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS version_types_server_rev_at_idx
    ON public.version_types USING btree
    (server_rev_at ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS version_types_sort_idx
    ON public.version_types USING btree
    (sort ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS version_types_value_idx
    ON public.version_types USING btree
    (value COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "Users can view version types"
    ON public.version_types
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE TRIGGER version_types_set_server_rev_at
    BEFORE INSERT OR UPDATE 
    ON public.version_types
    FOR EACH ROW
    EXECUTE FUNCTION public.set_server_rev_at();

CREATE TABLE IF NOT EXISTS public.rows
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    table_id uuid NOT NULL,
    parent_id uuid,
    geometry geometry(GeometryCollection,4326) DEFAULT NULL::geometry,
    geometry_n real,
    geometry_e real,
    geometry_s real,
    geometry_w real,
    data jsonb,
    client_rev_at timestamp with time zone DEFAULT now(),
    client_rev_by text COLLATE pg_catalog."default",
    server_rev_at timestamp with time zone DEFAULT now(),
    rev text COLLATE pg_catalog."default",
    parent_rev text COLLATE pg_catalog."default",
    revisions text[] COLLATE pg_catalog."default",
    depth integer DEFAULT 0,
    deleted boolean DEFAULT false,
    conflicts text[] COLLATE pg_catalog."default",
    CONSTRAINT rows_pkey PRIMARY KEY (id),
    CONSTRAINT rows_parent_id_fkey FOREIGN KEY (parent_id)
        REFERENCES public.rows (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION,
    CONSTRAINT rows_table_id_fkey FOREIGN KEY (table_id)
        REFERENCES public.tables (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.rows
    OWNER to postgres;

ALTER TABLE IF EXISTS public.rows
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.rows TO authenticated;

GRANT ALL ON TABLE public.rows TO anon;

GRANT ALL ON TABLE public.rows TO service_role;

GRANT ALL ON TABLE public.rows TO postgres;

COMMENT ON TABLE public.rows
    IS 'Goal: Collect data. Versioned';

COMMENT ON COLUMN public.rows.id
    IS 'primary key';

COMMENT ON COLUMN public.rows.table_id
    IS 'associated table';

COMMENT ON COLUMN public.rows.parent_id
    IS 'associated row in the parent table (which means: this row is part of a child table)';

COMMENT ON COLUMN public.rows.geometry
    IS 'row geometry (GeometryCollection)';

COMMENT ON COLUMN public.rows.geometry_n
    IS 'Northernmost point of the geometry. Used to filter geometries for viewport client-side';

COMMENT ON COLUMN public.rows.geometry_e
    IS 'Easternmost point of the geometry. Used to filter geometries for viewport client-side';

COMMENT ON COLUMN public.rows.geometry_s
    IS 'Southernmost point of the geometry. Used to filter geometries for viewport client-side';

COMMENT ON COLUMN public.rows.geometry_w
    IS 'Westernmost point of the geometry. Used to filter geometries for viewport client-side';

COMMENT ON COLUMN public.rows.data
    IS 'fields (keys) and data (values) according to the related fields table';

COMMENT ON COLUMN public.rows.client_rev_at
    IS 'time of last edit on client';

COMMENT ON COLUMN public.rows.client_rev_by
    IS 'user editing last on client';

COMMENT ON COLUMN public.rows.server_rev_at
    IS 'time of last edit on server';

COMMENT ON COLUMN public.rows.deleted
    IS 'marks if the row is deleted';
CREATE INDEX IF NOT EXISTS rows_data_idx
    ON public.rows USING gin
    (data)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS rows_deleted_idx
    ON public.rows USING btree
    (deleted ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS rows_deleted_idx1
    ON public.rows USING btree
    (deleted ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS rows_geometry_idx
    ON public.rows USING gist
    (geometry)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS rows_id_idx
    ON public.rows USING btree
    (id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS rows_parent_id_idx
    ON public.rows USING btree
    (parent_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS rows_table_id_idx
    ON public.rows USING btree
    (table_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "project managers and editors can delete rows"
    ON public.rows
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() IN ( SELECT users.auth_user_id
   FROM (((tables
     JOIN projects ON ((projects.id = tables.project_id)))
     JOIN project_users ON ((projects.id = project_users.project_id)))
     JOIN users ON ((users.email = project_users.user_email)))
  WHERE ((tables.id = rows.table_id) AND (project_users.role = ANY (ARRAY['project_manager'::text, 'project_editor'::text]))))));
CREATE POLICY "project managers and editors can insert rows"
    ON public.rows
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() IN ( SELECT users.auth_user_id
   FROM (((tables
     JOIN projects ON ((projects.id = tables.project_id)))
     JOIN project_users ON ((projects.id = project_users.project_id)))
     JOIN users ON ((users.email = project_users.user_email)))
  WHERE ((tables.id = rows.table_id) AND (project_users.role = ANY (ARRAY['project_manager'::text, 'project_editor'::text]))))));
CREATE POLICY "project managers and editors can update rows"
    ON public.rows
    AS PERMISSIVE
    FOR UPDATE
    TO public
    WITH CHECK ((auth.uid() IN ( SELECT users.auth_user_id
   FROM (((tables
     JOIN projects ON ((projects.id = tables.project_id)))
     JOIN project_users ON ((projects.id = project_users.project_id)))
     JOIN users ON ((users.email = project_users.user_email)))
  WHERE ((tables.id = rows.table_id) AND (project_users.role = ANY (ARRAY['project_manager'::text, 'project_editor'::text]))))));
CREATE POLICY "project readers, editors and managers can view rows"
    ON public.rows
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() IN ( SELECT users.auth_user_id
   FROM (((tables
     JOIN projects ON ((projects.id = tables.project_id)))
     JOIN project_users ON ((projects.id = project_users.project_id)))
     JOIN users ON ((users.email = project_users.user_email)))
  WHERE ((tables.id = rows.table_id) AND (project_users.role = ANY (ARRAY['project_manager'::text, 'project_editor'::text, 'project_reader'::text]))))));

CREATE TABLE IF NOT EXISTS public.tables
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    project_id uuid NOT NULL,
    parent_id uuid,
    rel_type text COLLATE pg_catalog."default" DEFAULT 'n'::text,
    name text COLLATE pg_catalog."default",
    label text COLLATE pg_catalog."default",
    single_label text COLLATE pg_catalog."default",
    label_fields text[] COLLATE pg_catalog."default",
    label_fields_separator text COLLATE pg_catalog."default" DEFAULT ', '::text,
    sort smallint,
    option_type text COLLATE pg_catalog."default",
    client_rev_at timestamp with time zone DEFAULT now(),
    client_rev_by text COLLATE pg_catalog."default",
    server_rev_at timestamp with time zone DEFAULT now(),
    deleted boolean DEFAULT false,
    CONSTRAINT tables_pkey PRIMARY KEY (id),
    CONSTRAINT tables_option_type_fkey FOREIGN KEY (option_type)
        REFERENCES public.option_types (value) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION,
    CONSTRAINT tables_parent_id_fkey FOREIGN KEY (parent_id)
        REFERENCES public.tables (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION,
    CONSTRAINT tables_project_id_fkey FOREIGN KEY (project_id)
        REFERENCES public.projects (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION,
    CONSTRAINT tables_rel_type_fkey FOREIGN KEY (rel_type)
        REFERENCES public.rel_types (value) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.tables
    OWNER to postgres;

ALTER TABLE IF EXISTS public.tables
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.tables TO authenticated;

GRANT ALL ON TABLE public.tables TO anon;

GRANT ALL ON TABLE public.tables TO service_role;

GRANT ALL ON TABLE public.tables TO postgres;

COMMENT ON TABLE public.tables
    IS 'Goal: Define tables used per project. Rows and files depend on it. Not versioned (not recorded and only added by manager)';

COMMENT ON COLUMN public.tables.id
    IS 'primary key';

COMMENT ON COLUMN public.tables.project_id
    IS 'associated project';

COMMENT ON COLUMN public.tables.parent_id
    IS 'parent table';

COMMENT ON COLUMN public.tables.rel_type
    IS 'releation with parent table: 1:1 or 1:n';

COMMENT ON COLUMN public.tables.name
    IS 'name for use in db and url (lowercase, no special characters)';

COMMENT ON COLUMN public.tables.label
    IS 'name for use when labeling';

COMMENT ON COLUMN public.tables.label_fields
    IS 'fields used to label and sort rows';

COMMENT ON COLUMN public.tables.label_fields_separator
    IS 'characters used to separate fields when labelling rows';

COMMENT ON COLUMN public.tables.sort
    IS 'enables ordering the tables of a project';

COMMENT ON COLUMN public.tables.option_type
    IS 'What type of options list will this be?';

COMMENT ON COLUMN public.tables.client_rev_at
    IS 'time of last edit on client';

COMMENT ON COLUMN public.tables.client_rev_by
    IS 'user editing last on client';

COMMENT ON COLUMN public.tables.server_rev_at
    IS 'time of last edit on server';
CREATE INDEX IF NOT EXISTS tables_deleted_idx
    ON public.tables USING btree
    (deleted ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS tables_id_idx
    ON public.tables USING btree
    (id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS tables_label_idx
    ON public.tables USING btree
    (label COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS tables_name_idx
    ON public.tables USING btree
    (name COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS tables_option_type_idx
    ON public.tables USING btree
    (option_type COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS tables_parent_id_idx
    ON public.tables USING btree
    (parent_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS tables_project_id_idx
    ON public.tables USING btree
    (project_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE UNIQUE INDEX IF NOT EXISTS tables_project_name_idx
    ON public.tables USING btree
    (project_id ASC NULLS LAST, name COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default
    WHERE deleted IS FALSE;
CREATE INDEX IF NOT EXISTS tables_sort_idx
    ON public.tables USING btree
    (sort ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "project managers can delete tables"
    ON public.tables
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() IN ( SELECT users.auth_user_id
   FROM ((projects
     JOIN project_users ON ((projects.id = project_users.project_id)))
     JOIN users ON ((users.email = project_users.user_email)))
  WHERE ((projects.id = tables.project_id) AND (project_users.role = 'project_manager'::text)))));
CREATE POLICY "project managers can insert tables"
    ON public.tables
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() IN ( SELECT users.auth_user_id
   FROM ((projects
     JOIN project_users ON ((projects.id = project_users.project_id)))
     JOIN users ON ((users.email = project_users.user_email)))
  WHERE ((projects.id = tables.project_id) AND (project_users.role = 'project_manager'::text)))));
CREATE POLICY "project managers can update tables"
    ON public.tables
    AS PERMISSIVE
    FOR UPDATE
    TO public
    WITH CHECK ((auth.uid() IN ( SELECT users.auth_user_id
   FROM ((projects
     JOIN project_users ON ((projects.id = project_users.project_id)))
     JOIN users ON ((users.email = project_users.user_email)))
  WHERE ((projects.id = tables.project_id) AND (project_users.role = 'project_manager'::text)))));
CREATE POLICY "project readers, editors and managers can view tables"
    ON public.tables
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() IN ( SELECT users.auth_user_id
   FROM ((projects
     JOIN project_users ON ((projects.id = project_users.project_id)))
     JOIN users ON ((users.email = project_users.user_email)))
  WHERE ((projects.id = tables.project_id) AND (project_users.role = ANY (ARRAY['project_manager'::text, 'project_editor'::text, 'project_reader'::text]))))));

CREATE TRIGGER tables_set_server_rev_at
    BEFORE INSERT OR UPDATE 
    ON public.tables
    FOR EACH ROW
    EXECUTE FUNCTION public.set_server_rev_at();

CREATE TABLE IF NOT EXISTS public.news_delivery
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    news_id uuid,
    user_id uuid,
    server_rev_at timestamp with time zone DEFAULT now(),
    deleted boolean DEFAULT false,
    CONSTRAINT news_delivery_pkey PRIMARY KEY (id),
    CONSTRAINT news_delivery_news_id_fkey FOREIGN KEY (news_id)
        REFERENCES public.news (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION,
    CONSTRAINT news_delivery_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.news_delivery
    OWNER to postgres;

ALTER TABLE IF EXISTS public.news_delivery
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.news_delivery TO authenticated;

GRANT ALL ON TABLE public.news_delivery TO anon;

GRANT ALL ON TABLE public.news_delivery TO service_role;

GRANT ALL ON TABLE public.news_delivery TO postgres;

COMMENT ON COLUMN public.news_delivery.id
    IS 'primary key';

COMMENT ON COLUMN public.news_delivery.news_id
    IS 'associated news';

COMMENT ON COLUMN public.news_delivery.user_id
    IS 'associated user';

COMMENT ON COLUMN public.news_delivery.server_rev_at
    IS 'time of last edit on server';
CREATE INDEX IF NOT EXISTS news_delivery_deleted_idx
    ON public.news_delivery USING btree
    (deleted ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS news_delivery_id_idx
    ON public.news_delivery USING btree
    (id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS news_delivery_news_id_idx
    ON public.news_delivery USING btree
    (news_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS news_delivery_user_id_idx
    ON public.news_delivery USING btree
    (user_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "Users can view their own option types"
    ON public.news_delivery
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() IN ( SELECT users.auth_user_id
   FROM (users
     JOIN news_delivery nd ON ((users.auth_user_id = nd.user_id)))
  WHERE (nd.id = news_delivery.id))));

CREATE TRIGGER news_delivery_set_server_rev_at
    BEFORE INSERT OR UPDATE 
    ON public.news_delivery
    FOR EACH ROW
    EXECUTE FUNCTION public.set_server_rev_at();

CREATE TABLE IF NOT EXISTS public.accounts
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    service_id text COLLATE pg_catalog."default",
    client_rev_at timestamp with time zone DEFAULT now(),
    client_rev_by text COLLATE pg_catalog."default",
    server_rev_at timestamp with time zone DEFAULT now(),
    deleted boolean DEFAULT false,
    CONSTRAINT accounts_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.accounts
    OWNER to postgres;

ALTER TABLE IF EXISTS public.accounts
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.accounts TO anon;

GRANT ALL ON TABLE public.accounts TO authenticated;

GRANT ALL ON TABLE public.accounts TO postgres;

GRANT ALL ON TABLE public.accounts TO service_role;

COMMENT ON TABLE public.accounts
    IS 'Goal: earn money. Base table. Projects, tables, rows and files depend on it. Not versioned (not recorded and only added by manager)';

COMMENT ON COLUMN public.accounts.id
    IS 'primary key';

COMMENT ON COLUMN public.accounts.service_id
    IS 'id used by external service';

COMMENT ON COLUMN public.accounts.client_rev_at
    IS 'time of last edit on client';

COMMENT ON COLUMN public.accounts.client_rev_by
    IS 'user editing last on client';

COMMENT ON COLUMN public.accounts.server_rev_at
    IS 'time of last edit on server';
CREATE INDEX IF NOT EXISTS accounts_deleted_idx
    ON public.accounts USING btree
    (deleted ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS accounts_id_idx
    ON public.accounts USING btree
    (id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS accounts_server_rev_at_idx
    ON public.accounts USING btree
    (server_rev_at ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS accounts_service_id_idx
    ON public.accounts USING btree
    (service_id COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "Users can insert own account"
    ON public.accounts
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() IN ( SELECT users.auth_user_id
   FROM users
  WHERE (users.account_id = accounts.id))));
CREATE POLICY "Users can update own account"
    ON public.accounts
    AS PERMISSIVE
    FOR UPDATE
    TO public
    WITH CHECK ((auth.uid() IN ( SELECT users.auth_user_id
   FROM users
  WHERE (users.account_id = accounts.id))));
CREATE POLICY "Users can view own account"
    ON public.accounts
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() IN ( SELECT users.auth_user_id
   FROM users
  WHERE (users.account_id = accounts.id))));
CREATE POLICY "Users cant delete accounts"
    ON public.accounts
    AS PERMISSIVE
    FOR UPDATE
    TO public
    WITH CHECK (false);

CREATE TRIGGER accounts_set_server_rev_at
    BEFORE INSERT OR UPDATE 
    ON public.accounts
    FOR EACH ROW
    EXECUTE FUNCTION public.set_server_rev_at();

CREATE TABLE IF NOT EXISTS public.file_revs
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    row_id uuid,
    file_id uuid,
    field_id uuid,
    filename text COLLATE pg_catalog."default",
    url text COLLATE pg_catalog."default",
    version integer,
    deleted boolean DEFAULT false,
    client_rev_at timestamp with time zone,
    client_rev_by text COLLATE pg_catalog."default",
    server_rev_at timestamp with time zone DEFAULT now(),
    rev text COLLATE pg_catalog."default",
    parent_rev text COLLATE pg_catalog."default",
    revisions text[] COLLATE pg_catalog."default",
    depth integer DEFAULT 0,
    CONSTRAINT file_revs_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.file_revs
    OWNER to postgres;

ALTER TABLE IF EXISTS public.file_revs
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.file_revs TO anon;

GRANT ALL ON TABLE public.file_revs TO authenticated;

GRANT ALL ON TABLE public.file_revs TO postgres;

GRANT ALL ON TABLE public.file_revs TO service_role;

COMMENT ON TABLE public.file_revs
    IS 'Goal: Sync files and handle conflicts';

COMMENT ON COLUMN public.file_revs.id
    IS 'primary key';

COMMENT ON COLUMN public.file_revs.file_id
    IS 'key of table files';

COMMENT ON COLUMN public.file_revs.rev
    IS 'hashed value the fields: file_id, field_id, filename, hash, version, deleted';

COMMENT ON COLUMN public.file_revs.parent_rev
    IS 'hash of the previous revision';

COMMENT ON COLUMN public.file_revs.revisions
    IS 'array of hashes of all previous revisions';

COMMENT ON COLUMN public.file_revs.depth
    IS 'depth of the revision tree';
CREATE INDEX IF NOT EXISTS file_revs_deleted_idx
    ON public.file_revs USING btree
    (deleted ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS file_revs_depth_idx
    ON public.file_revs USING btree
    (depth ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS file_revs_file_id_idx
    ON public.file_revs USING btree
    (file_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS file_revs_id_idx
    ON public.file_revs USING btree
    (id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS file_revs_parent_rev_idx
    ON public.file_revs USING btree
    (parent_rev COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS file_revs_rev_idx
    ON public.file_revs USING btree
    (rev COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS file_revs_row_id_idx
    ON public.file_revs USING btree
    (row_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS file_revs_server_rev_at_idx
    ON public.file_revs USING btree
    (server_rev_at ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "authenticated users can insert file_revs"
    ON public.file_revs
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.role() = 'authenticated'::text));
CREATE POLICY "authenticated users can view file_revs"
    ON public.file_revs
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.role() = 'authenticated'::text));
CREATE POLICY "file_revs can not be deleted"
    ON public.file_revs
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING (false);
CREATE POLICY "file_revs can not be updated"
    ON public.file_revs
    AS PERMISSIVE
    FOR UPDATE
    TO public
    WITH CHECK (false);

CREATE TRIGGER trigger_file_revs_set_winning_revision
    AFTER INSERT
    ON public.file_revs
    FOR EACH ROW
    EXECUTE FUNCTION public.file_revs_set_winning_revision();

CREATE OR REPLACE VIEW public.project_editors
 AS
 SELECT project_users.id,
    project_users.project_id,
    project_users.user_email,
    project_users.role,
    project_users.client_rev_at,
    project_users.client_rev_by,
    project_users.server_rev_at,
    project_users.deleted
   FROM project_users
  WHERE project_users.role = 'project_editor'::text;

ALTER TABLE public.project_editors
    OWNER TO postgres;

GRANT ALL ON TABLE public.project_editors TO authenticated;
GRANT ALL ON TABLE public.project_editors TO postgres;
GRANT ALL ON TABLE public.project_editors TO anon;
GRANT ALL ON TABLE public.project_editors TO service_role;

CREATE OR REPLACE VIEW public.project_readers
 AS
 SELECT project_users.id,
    project_users.project_id,
    project_users.user_email,
    project_users.role,
    project_users.client_rev_at,
    project_users.client_rev_by,
    project_users.server_rev_at,
    project_users.deleted
   FROM project_users
  WHERE project_users.role = 'project_reader'::text;

ALTER TABLE public.project_readers
    OWNER TO postgres;

GRANT ALL ON TABLE public.project_readers TO authenticated;
GRANT ALL ON TABLE public.project_readers TO postgres;
GRANT ALL ON TABLE public.project_readers TO anon;
GRANT ALL ON TABLE public.project_readers TO service_role;

CREATE OR REPLACE VIEW public.project_managers
 AS
 SELECT project_users.id,
    project_users.project_id,
    project_users.user_email,
    project_users.role,
    project_users.client_rev_at,
    project_users.client_rev_by,
    project_users.server_rev_at,
    project_users.deleted
   FROM project_users
  WHERE project_users.role = 'project_manager'::text;

ALTER TABLE public.project_managers
    OWNER TO postgres;

GRANT ALL ON TABLE public.project_managers TO authenticated;
GRANT ALL ON TABLE public.project_managers TO postgres;
GRANT ALL ON TABLE public.project_managers TO anon;
GRANT ALL ON TABLE public.project_managers TO service_role;
